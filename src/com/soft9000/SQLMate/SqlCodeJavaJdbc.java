/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.soft9000.SQLMate;

/**
 *
 * @author profnagy
 */
// TODO:  (INSERT USAGE: ID / Primary Key Autoinc)   ref.setNull(1, java.sql.Types.INTEGER);
public class SqlCodeJavaJdbc extends SqlObject implements ISchemaValidator, ISchemaWriter {

    private SqlTable Table = new SqlTable();
    private SqlConnectionJdbc conn = new SqlConnectionJdbc();

    private boolean WantDaoInsert = true;
    private boolean WantDaoDelete = true;
    private boolean WantDaoUpdate = true;
    private boolean WantDaoSelect = true;

    private boolean WantTableCreate = true;
    private boolean WantTableDelete = true;

    public String getClassName() {
        StringBuilder sb = new StringBuilder();
        sb.append("Sql");
        sb.append(this.getTable().getTableName());
        return sb.toString();
    }

    @Override
    public void validate() throws ExInvalid {
        getTable().validate();
        getConn().validate();
    }

    @Override
    public void write(StringBuilder sb) throws ExInvalid {
        validate();
        writeHeader(sb);
        sb.append("public class ");
        sb.append(getClassName());
        sb.append(" {\n");
        sb.append("\tpublic static final int NO_ID = -1;\n");

        this.writeConn(sb);
        this.writeFields(sb);

        this.writeGetters(sb);
        this.writeSetters(sb);

        if (this.isWantDaoInsert()) {
            this.writeDaoInsert(sb);
            this.writeDaoGetLastInsert(sb);
        }
        if (this.isWantDaoSelect()) {
            this.writeDaoSelect(sb);
        }
        if (this.isWantDaoUpdate()) {
            this.writeDaoUpdate(sb);
        }
        if (this.isWantDaoDelete()) {
            this.writeDaoDelete(sb);
        }
        if (this.isWantTableCreate()) {
            this.writeTableCreate(sb);
        }
        if (this.isWantTableDelete()) {
            this.writeTableDelete(sb);
        }
        this.writeColumnInfo(sb);
        this.writeMainTest(sb);

        sb.append("\n}\n\n");
    }

    private void writeHeader(StringBuilder sb) throws ExInvalid {
        sb.append("/* THIS CLASS WAS GENERATED BY SQLMate .05\n");
        sb.append("   The targeted SQL technology is SQLite3.\n");
        sb.append("   Test case main.java documents tested level of support.\n");
        sb.append("   Your project will need to include sqlite-jdbc.jar:\n");
        sb.append("   -We used sqlite-jdbc-3.8.11.2.jar\n");
        sb.append("*/\n\n");

        sb.append("package ");
        getConn().getJavaPackageName(sb);
        sb.append(";\n\n");

        sb.append("import java.sql.Connection;\n"
                + "import java.sql.PreparedStatement;\n"
                + "import java.sql.ResultSet;\n"
                + "import java.sql.SQLException;\n"
                + "import java.sql.Statement;\n"
                + "import java.util.ArrayList;\n"
                + "import java.util.List;\n"
                + "import java.sql.DriverManager;\n"
                + "import com.soft9000.SQLMate.EColumnType;\n"
                + "import com.soft9000.SQLMate.SqlColumn;\n"
                + "\n");
    }

    private void writeTableCreate(StringBuilder sb) throws ExInvalid {
        sb.append("public void createTable(Connection conn) throws SQLException {\n");
        checkConn(sb);
        sb.append("\tStatement ref = conn.createStatement();");
        sb.append("\tString sql = \"");
        sb.append(this.getTable().writeTableCreate());
        sb.append("\";\n");
        sb.append("\tref.execute(sql);\n");
        sb.append("}\n\n");
    }

    private void writeTableDelete(StringBuilder sb) throws ExInvalid {
        sb.append("public void deleteTable(Connection conn) throws SQLException {\n");
        checkConn(sb);
        sb.append("\tStatement ref = conn.createStatement();");
        sb.append("\tString sql = \"");
        sb.append(this.getTable().writeTableDrop());
        sb.append("\";\n");
        sb.append("\tref.execute(sql);\n");
        sb.append("}\n\n");
    }

    private void writeDaoInsert(StringBuilder sb) throws ExInvalid {
        sb.append("public boolean insert(Connection conn) throws SQLException {\n");
        checkConn(sb);
        {
            StringBuilder sub = new StringBuilder();
            sub.append("INSERT INTO ");
            sub.append(this.getTable().getTableName());
            sub.append(" (");
            int count = 0;
            for (SqlColumn ref : this.getTable().getColumns()) {
                if (ref.isPrimaryKey()) {
                    continue;
                }
                if (count != 0) {
                    sub.append(", ");
                }
                sub.append(ref.getColumnName());
                count++;
            }
            sub.append(" ) VALUES (");
            for (int ss = 0; ss < count; ss++) {
                if (ss != 0) {
                    sub.append(", ");
                }
                sub.append("?");
            }
            sub.append(") ;");
            sb.append("\tPreparedStatement ref = conn.prepareStatement(\"");
            sb.append(sub.toString());
            sb.append("\");\n");
        }
        int count = 0;
        for (int ss = 0; ss < this.getTable().getColumns().size(); ss++) {
            SqlColumn ref = this.getTable().getColumns().get(ss);
            if (ref.isPrimaryKey()) {
                continue;
            }
            count++;
            prepProp(count, ref, sb);
        }
        sb.append("\tint result = ref.executeUpdate();\n"
                + "\treturn (result == 1);\n");
        sb.append("}\n\n");
    }

    private void writeDaoUpdate(StringBuilder sb) throws ExInvalid {
        sb.append("public boolean update(Connection conn) throws SQLException {\n");
        checkConn(sb);
        {
            StringBuilder sub = new StringBuilder();
            sub.append("UPDATE ");
            sub.append(this.getTable().getTableName());
            sub.append(" SET ");
            int count = 0;
            for (SqlColumn ref : this.getTable().getColumns()) {
                if (ref.isPrimaryKey()) {
                    continue;
                }
                if (count != 0) {
                    sub.append(", ");
                }
                sub.append(ref.getColumnName());
                sub.append(" = ?");
                count++;
            }
            sub.append(" WHERE ID = ? ;");

            sb.append("\tPreparedStatement ref = conn.prepareStatement(\"");
            sb.append(sub.toString());
            sb.append("\");\n");
        }
        SqlColumn refID = null;
        int count = 0;
        for (int ss = 0; ss < this.getTable().getColumns().size(); ss++) {
            SqlColumn ref = this.getTable().getColumns().get(ss);
            if (ref.getColumnName().equals("ID")) {
                refID = ref;
            }
            if (ref.isPrimaryKey()) {
                continue;
            }
            count++;
            prepProp(count, ref, sb);
        }
        prepProp(count + 1, refID, sb);
        sb.append("\tint result = ref.executeUpdate();\n"
                + "\treturn (result == 1);\n");
        sb.append("}\n\n");
    }

    private void writeDaoDelete(StringBuilder sb) throws ExInvalid {
        sb.append("public boolean delete(Connection conn) throws SQLException {\n");
        checkConn(sb);
        sb.append("\tif (this.getID() == NO_ID) {\n"
                + "\t\tthrow new SQLException(\"Object ID is NULL.\");\n"
                + "\t}\n\n"
                + "\tStatement ref = conn.createStatement();\n");
        sb.append("\tint result = ref.executeUpdate(\"");
        sb.append("DELETE FROM ");
        sb.append(this.getTable().getTableName());
        sb.append(" WHERE ID = \" + this.getID() + \" ;\");\n"
                + "\treturn (result == 1);\n");
        sb.append("}\n\n");
    }

    private void writeDaoSelect(StringBuilder sb) throws ExInvalid {
        sb.append("public List<");
        sb.append(getClassName());
        sb.append("> select(Connection conn, String sqlSelect) throws SQLException {\n");
        checkConn(sb);
        sb.append("\tStatement smt = conn.createStatement();\n"
                + "\tResultSet set = smt.executeQuery(sqlSelect);\n");

        sb.append("\tArrayList<" + this.getClassName() + "> result = new ArrayList<" + this.getClassName() + ">();\n");
        sb.append("\twhile (set.next()) {\n");
        sb.append(this.getClassName());
        sb.append(" ref = new ");
        sb.append(this.getClassName());
        sb.append("();\n");
        for (SqlColumn ref : this.getTable().getColumns()) {
            switch (ref.getSqlType()) {
                case Long:
                    sb.append("\tref.set" + ref.getColumnName() + "(set.getLong(\"" + ref.getColumnName() + "\"));\n");
                    break;
                case Integer:
                    sb.append("\tref.set" + ref.getColumnName() + "(set.getInt(\"" + ref.getColumnName() + "\"));\n");
                    break;
                case Text:
                    sb.append("\tref.set" + ref.getColumnName() + "(set.getString(\"" + ref.getColumnName() + "\"));\n");
                    break;
                case Real:
                    sb.append("\tref.set" + ref.getColumnName() + "(set.getFloat(\"" + ref.getColumnName() + "\"));\n");
                    break;
                case Blob:
                    sb.append("\tref.set" + ref.getColumnName() + "(set.getBytes(\"" + ref.getColumnName() + "\"));\n");
                    break;
                default:
                    throw new ExInvalid("Unsupported type: " + ref.getSqlType().name());
            }
        }
        sb.append("\tresult.add(ref);");
        sb.append("\t}\n\n");
        sb.append("return result;\n");
        sb.append("}\n\n");
    }

    private void writeDaoGetLastInsert(StringBuilder sb) throws ExInvalid {
        sb.append("public int lastInsert(Connection conn) throws SQLException {\n");
        sb.append("\tStatement smt = conn.createStatement();\n");
        sb.append("\tResultSet set = smt.executeQuery(\"SELECT ID From \" + sTableName + \" DESC LIMIT 1;\");\n");

        sb.append("\tint result = NO_ID;\n");
        sb.append("\twhile (set.next()) {\n");
        sb.append("\t\tresult = set.getInt(\"ID\");\n");
        sb.append("\t}\n");
        sb.append("\treturn result;\n");
        sb.append("}\n\n");
        validate();
    }

    private void checkConn(StringBuilder sb) {
        sb.append("\tif (conn == null) {\n"
                + "\t\tthrow new SQLException(\"Connection Object Reference is NULL.\");\n"
                + "\t}\n\n");
    }

    private void prepProp(int ss, SqlColumn ref, StringBuilder sb) throws ExInvalid {
        switch (ref.getSqlType()) {
            case Long:
                sb.append("\tref.setLong(");
                sb.append(ss);
                sb.append(", this.get" + ref.getColumnName() + "()");
                sb.append(");\n");
                break;
            case Integer:
                sb.append("\tref.setInt(");
                sb.append(ss);
                sb.append(", this.get" + ref.getColumnName() + "()");
                sb.append(");\n");
                break;
            case Text:
                sb.append("\tref.setString(");
                sb.append(ss);
                sb.append(", this.get" + ref.getColumnName() + "()");
                sb.append(");\n");
                break;
            case Real:
                sb.append("\tref.setFloat(");
                sb.append(ss);
                sb.append(", this.get" + ref.getColumnName() + "()");
                sb.append(");\n");
                break;
            case Blob:
                sb.append("\tref.setBytes(");
                sb.append(ss);
                sb.append(", this.get" + ref.getColumnName() + "()");
                sb.append(");\n");
                break;
            default:
                throw new ExInvalid("Unsupported Column Type: '" + ref.getSqlType().name() + "' !");
        }
    }

    private void writeSetters(StringBuilder sb) throws ExInvalid {
        for (SqlColumn ref : this.getTable().getColumns()) {
            mkSetter(sb, ref);
        }
    }

    private void writeGetters(StringBuilder sb) throws ExInvalid {
        for (SqlColumn ref : this.getTable().getColumns()) {
            mkGetter(sb, ref);
        }
    }

    private void mkSetter(StringBuilder sb, final SqlColumn ref) throws ExInvalid {
        sb.append("public boolean set");
        sb.append(ref.getColumnName());
        sb.append("(");
        sb.append(ref.getSqlType().getJavaType());
        sb.append(" ");
        sb.append(" param");
        sb.append(") {\n");
        if (ref.getSqlType().isJavaPrimitive() == false) {
            sb.append("\tif(param == null)\n\t\treturn false;\n");
        }
        sb.append("\tthis.");
        sb.append(ref.getColumnName());
        sb.append(" = param;\n\treturn true;");
        sb.append("\n}\n\n");
    }

    private void mkGetter(StringBuilder sb, final SqlColumn ref) throws ExInvalid {
        sb.append("public ");
        sb.append(ref.getSqlType().getJavaType());
        sb.append(" get");
        sb.append(ref.getColumnName());
        sb.append("() {\n");
        sb.append("\treturn this.");
        sb.append(ref.getColumnName());
        sb.append(";\n}\n\n");
    }

    private void writeFields(StringBuilder sb) throws ExInvalid {
        for (SqlColumn ref : this.getTable().getColumns()) {
            mkField(sb, ref);
        }
    }

    private void mkField(StringBuilder sb, final SqlColumn ref) throws ExInvalid {
        sb.append("\t");
        switch (ref.getSqlType()) {
            case Long:
                sb.append("long");
                break;
            case Integer:
                sb.append("int");
                break;
            case Text:
                sb.append("String");
                break;
            case Real:
                sb.append("float");
                break;
            case Blob:
                sb.append("byte[]");
                break;
            default:
                throw new ExInvalid("Unsupported type: '" + ref.getSqlType().name() + "' !");
        }
        sb.append(" ");
        sb.append(ref.getColumnName());
        sb.append(" = ");
        sb.append(EColumnType.GetDefaultJavaValue(ref));
        sb.append(";\n");
    }

    private void writeConn(StringBuilder sb) throws ExInvalid {
        sb.append("\npublic static String CONN_STRING =");
        sb.append(" \"");
        this.getConn().writeConnectionString(sb);
        sb.append("\";\n\n");

        sb.append("public static Connection Connect() throws ClassNotFoundException, SQLException {\n"
                + "\treturn Connect(CONN_STRING);\n"
                + "}\n\n"
                + "public static Connection Connect(String fileName) throws ClassNotFoundException, SQLException {\n"
                + "\tif (fileName == null) {\n"
                + "\t\tthrow new SQLException(\"File name cannot be NULL.\");\n"
                + "\t}\n\n"
                + "\tClass.forName(\"org.sqlite.JDBC\");\n"
                + "\tConnection conn = DriverManager.getConnection(fileName);\n"
                + "\treturn conn;\n"
                + " }\n\n"
                + "public static void Cleanup(Connection conn) throws SQLException {\n"
                + "\tif (conn == null) {\n"
                + "\t\tthrow new SQLException(\"Connection Object Reference is NULL.\");\n"
                + "\t}\n\n"
                + "\tStatement ref = conn.createStatement();\n"
                + "\tref.execute(\"VACUUM\");\n"
                + "\t}\n\n");
    }

    private void writeMainTest(StringBuilder sb) throws ExInvalid {
        sb.append("public static void main(String ... args) throws ClassNotFoundException, SQLException {\n");
        sb.append("\tConnection conn = Connect(\"jdbc:sqlite:~test.tmp\");\n"
                + "\t" + this.getClassName() + " ref = new " + this.getClassName() + "();\n");

        sb.append("\n// TEST TABLE OPS:\n");
        {
            sb.append("\tref.deleteTable(conn);\n");

            sb.append("\tref.createTable(conn);\n");
        }

        sb.append("\n// TEST INSERT:\n");
        {
            tcSetter(0, sb, false);
            tcSetterCheck(0, sb, false);
            sb.append("\n\tif (ref.insert(conn) == false) {\n"
                    + "\t\tthrow new SQLException(\"Test Case 'insert' Error\");\n"
                    + "\t}\n\n");
        }

        sb.append("\n// TEST INSERT:\n");
        {
            tcSetter(0, sb, false);
            tcSetterCheck(0, sb, false);
            sb.append("\n\tif (ref.insert(conn) == false) {\n"
                    + "\t\tthrow new SQLException(\"Test Case 'insert' Error\");\n"
                    + "\t}\n\n");
        }

        sb.append("\n// TEST GET LAST INSERT:\n");
        {
            sb.append("\n\tif(ref.lastInsert(conn) == NO_ID) {\n");
            sb.append("\t\tthrow new SQLException(\"Test Case 'lastInsert' Error\");\n"
                    + "\t}\n\n");
        }

        sb.append("\n// TEST UPDATE:\n");
        {
            tcSetter(10, sb, true);
            sb.append("\tif(ref.update(conn) == false) {\n");
            sb.append("\t\tthrow new SQLException(\"Test Case 'update 1' Error\");\n");
            sb.append("\t}\n\n");
            tcSetterCheck(10, sb, true);
        }

        sb.append("\n// TEST DELETE:\n");
        {
            sb.append("\tif(ref.delete(conn) == false) {\n"
                    + "\t\tthrow new SQLException(\"Test Case 'delete' Error\");\n"
                    + "\t}\n\n");
        }

        sb.append("ref.deleteTable(conn);");

        sb.append("}\n\n");
    }

    private void tcSetter(int base, StringBuilder sb, boolean skipID) throws ExInvalid {
        for (int ss = 0; ss < this.getTable().getColumns().size(); ss++) {
            SqlColumn ref = this.getTable().getColumns().get(ss);
            if (skipID && ref.getColumnName().equals("ID")) {
                continue;
            }
            sb.append("\tref.set");
            sb.append(ref.getColumnName());
            sb.append("(");
            sb.append(ref.getSqlType().mkJavaParam(base + ss + 1));
            sb.append(");\n");
        }
    }

    private void tcSetterCheck(int base, StringBuilder sb, boolean skipID) throws ExInvalid {
        for (int ss = 0; ss < this.getTable().getColumns().size(); ss++) {
            SqlColumn ref = this.getTable().getColumns().get(ss);
            if (ref.getSqlType() == EColumnType.Blob) {
                sb.append("\n// BLOB: Run-time okay - test case scheduled for another release.\n");
                continue;
            }
            if (skipID && ref.getColumnName().equals("ID")) {
                continue;
            }
            sb.append("if(ref.get" + ref.getColumnName() + "()");
            if (ref.getSqlType().isJavaPrimitive()) {
                sb.append(" != ");
                sb.append(ref.getSqlType().mkJavaParam(base + ss + 1));
                sb.append(") {\n");
            } else {
                sb.append(".equals(");
                sb.append(ref.getSqlType().mkJavaParam(base + ss + 1));
                sb.append(")");
                sb.append(" == false) {\n");
            }
            sb.append("\t\tthrow new SQLException(\"Test Case 'checker 1." + (base + ss + 1) + "' Error\");\n");
            sb.append("}\n\n");
        }
    }

    public static void main(String... args) throws ExInvalid {
        main.main(args);
    }

    /**
     * @return the Table
     */
    public SqlTable getTable() {
        return Table;
    }

    /**
     * @param Table the Table to set
     */
    public void setTable(SqlTable Table) {
        this.Table = Table;
    }

    /**
     * @return the conn
     */
    public SqlConnectionJdbc getConn() {
        return conn;
    }

    /**
     * @param conn the conn to set
     */
    public void setConn(SqlConnectionJdbc conn) {
        this.conn = conn;
    }

    /**
     * @return the WantDaoInsert
     */
    public boolean isWantDaoInsert() {
        return WantDaoInsert;
    }

    /**
     * @param WantDaoInsert the WantDaoInsert to set
     */
    public void setWantDaoInsert(boolean WantDaoInsert) {
        this.WantDaoInsert = WantDaoInsert;
    }

    /**
     * @return the WantDaoDelete
     */
    public boolean isWantDaoDelete() {
        return WantDaoDelete;
    }

    /**
     * @param WantDaoDelete the WantDaoDelete to set
     */
    public void setWantDaoDelete(boolean WantDaoDelete) {
        this.WantDaoDelete = WantDaoDelete;
    }

    /**
     * @return the WantDaoUpdate
     */
    public boolean isWantDaoUpdate() {
        return WantDaoUpdate;
    }

    /**
     * @param WantDaoUpdate the WantDaoUpdate to set
     */
    public void setWantDaoUpdate(boolean WantDaoUpdate) {
        this.WantDaoUpdate = WantDaoUpdate;
    }

    /**
     * @return the WantDaoSelect
     */
    public boolean isWantDaoSelect() {
        return WantDaoSelect;
    }

    /**
     * @param WantDaoSelect the WantDaoSelect to set
     */
    public void setWantDaoSelect(boolean WantDaoSelect) {
        this.WantDaoSelect = WantDaoSelect;
    }

    /**
     * @return the WantTableCreate
     */
    public boolean isWantTableCreate() {
        return WantTableCreate;
    }

    /**
     * @param WantTableCreate the WantTableCreate to set
     */
    public void setWantTableCreate(boolean WantTableCreate) {
        this.WantTableCreate = WantTableCreate;
    }

    /**
     * @return the WantTableDelete
     */
    public boolean isWantTableDelete() {
        return WantTableDelete;
    }

    /**
     * @param WantTableDelete the WantTableDelete to set
     */
    public void setWantTableDelete(boolean WantTableDelete) {
        this.WantTableDelete = WantTableDelete;
    }

    private void writeColumnInfo(StringBuilder sb) throws ExInvalid {
        sb.append("\n\n\tfinal String sTableName = \"");
        sb.append(this.Table.getTableName());
        sb.append("\";");
        sb.append(this.Table.writeColumnInfo());
        sb.append("\n\npublic String getTableName() {\n");
        sb.append("return sTableName;\n}\n\n");
    }
}
